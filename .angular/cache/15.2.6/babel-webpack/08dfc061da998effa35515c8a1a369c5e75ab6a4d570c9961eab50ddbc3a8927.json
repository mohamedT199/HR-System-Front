{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { forwardRef, EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nfunction Knob__svg_text_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"text\", 5);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"x\", 50)(\"y\", 57)(\"fill\", ctx_r0.textColor)(\"name\", ctx_r0.name);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.valueToDisplay());\n  }\n}\nconst KNOB_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => Knob),\n  multi: true\n};\nlet Knob = /*#__PURE__*/(() => {\n  class Knob {\n    constructor(document, renderer, cd, el) {\n      this.document = document;\n      this.renderer = renderer;\n      this.cd = cd;\n      this.el = el;\n      this.valueColor = 'var(--primary-color, Black)';\n      this.rangeColor = 'var(--surface-border, LightGray)';\n      this.textColor = 'var(--text-color-secondary, Black)';\n      this.valueTemplate = '{value}';\n      this.size = 100;\n      this.step = 1;\n      this.min = 0;\n      this.max = 100;\n      this.strokeWidth = 14;\n      this.showValue = true;\n      this.readonly = false;\n      this.onChange = new EventEmitter();\n      this.radius = 40;\n      this.midX = 50;\n      this.midY = 50;\n      this.minRadians = 4 * Math.PI / 3;\n      this.maxRadians = -Math.PI / 3;\n      this.value = null;\n      this.onModelChange = () => {};\n      this.onModelTouched = () => {};\n    }\n    mapRange(x, inMin, inMax, outMin, outMax) {\n      return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n    }\n    onClick(event) {\n      if (!this.disabled && !this.readonly) {\n        this.updateValue(event.offsetX, event.offsetY);\n      }\n    }\n    updateValue(offsetX, offsetY) {\n      let dx = offsetX - this.size / 2;\n      let dy = this.size / 2 - offsetY;\n      let angle = Math.atan2(dy, dx);\n      let start = -Math.PI / 2 - Math.PI / 6;\n      this.updateModel(angle, start);\n    }\n    updateModel(angle, start) {\n      let mappedValue;\n      if (angle > this.maxRadians) mappedValue = this.mapRange(angle, this.minRadians, this.maxRadians, this.min, this.max);else if (angle < start) mappedValue = this.mapRange(angle + 2 * Math.PI, this.minRadians, this.maxRadians, this.min, this.max);else return;\n      let newValue = Math.round((mappedValue - this.min) / this.step) * this.step + this.min;\n      this.value = newValue;\n      this.onModelChange(this.value);\n      this.onChange.emit(this.value);\n    }\n    onMouseDown(event) {\n      if (!this.disabled && !this.readonly) {\n        const window = this.document.defaultView || 'window';\n        this.windowMouseMoveListener = this.renderer.listen(window, 'mousemove', this.onMouseMove.bind(this));\n        this.windowMouseUpListener = this.renderer.listen(window, 'mouseup', this.onMouseUp.bind(this));\n        event.preventDefault();\n      }\n    }\n    onMouseUp(event) {\n      if (!this.disabled && !this.readonly) {\n        if (this.windowMouseMoveListener) {\n          this.windowMouseMoveListener();\n          this.windowMouseUpListener = null;\n        }\n        if (this.windowMouseUpListener) {\n          this.windowMouseUpListener();\n          this.windowMouseMoveListener = null;\n        }\n        event.preventDefault();\n      }\n    }\n    onTouchStart(event) {\n      if (!this.disabled && !this.readonly) {\n        const window = this.document.defaultView || 'window';\n        this.windowTouchMoveListener = this.renderer.listen(window, 'touchmove', this.onTouchMove.bind(this));\n        this.windowTouchEndListener = this.renderer.listen(window, 'touchend', this.onTouchEnd.bind(this));\n        event.preventDefault();\n      }\n    }\n    onTouchEnd(event) {\n      if (!this.disabled && !this.readonly) {\n        this.windowTouchMoveListener();\n        this.windowTouchEndListener();\n        this.windowTouchMoveListener = null;\n        this.windowTouchEndListener = null;\n        event.preventDefault();\n      }\n    }\n    onMouseMove(event) {\n      if (!this.disabled && !this.readonly) {\n        this.updateValue(event.offsetX, event.offsetY);\n        event.preventDefault();\n      }\n    }\n    onTouchMove(event) {\n      if (!this.disabled && !this.readonly && event.touches.length == 1) {\n        const rect = this.el.nativeElement.children[0].getBoundingClientRect();\n        const touch = event.targetTouches.item(0);\n        const offsetX = touch.clientX - rect.left;\n        const offsetY = touch.clientY - rect.top;\n        this.updateValue(offsetX, offsetY);\n      }\n    }\n    writeValue(value) {\n      this.value = value;\n      this.cd.markForCheck();\n    }\n    registerOnChange(fn) {\n      this.onModelChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onModelTouched = fn;\n    }\n    setDisabledState(val) {\n      this.disabled = val;\n      this.cd.markForCheck();\n    }\n    containerClass() {\n      return {\n        'p-knob p-component': true,\n        'p-disabled': this.disabled\n      };\n    }\n    rangePath() {\n      return `M ${this.minX()} ${this.minY()} A ${this.radius} ${this.radius} 0 1 1 ${this.maxX()} ${this.maxY()}`;\n    }\n    valuePath() {\n      return `M ${this.zeroX()} ${this.zeroY()} A ${this.radius} ${this.radius} 0 ${this.largeArc()} ${this.sweep()} ${this.valueX()} ${this.valueY()}`;\n    }\n    zeroRadians() {\n      if (this.min > 0 && this.max > 0) return this.mapRange(this.min, this.min, this.max, this.minRadians, this.maxRadians);else return this.mapRange(0, this.min, this.max, this.minRadians, this.maxRadians);\n    }\n    valueRadians() {\n      return this.mapRange(this._value, this.min, this.max, this.minRadians, this.maxRadians);\n    }\n    minX() {\n      return this.midX + Math.cos(this.minRadians) * this.radius;\n    }\n    minY() {\n      return this.midY - Math.sin(this.minRadians) * this.radius;\n    }\n    maxX() {\n      return this.midX + Math.cos(this.maxRadians) * this.radius;\n    }\n    maxY() {\n      return this.midY - Math.sin(this.maxRadians) * this.radius;\n    }\n    zeroX() {\n      return this.midX + Math.cos(this.zeroRadians()) * this.radius;\n    }\n    zeroY() {\n      return this.midY - Math.sin(this.zeroRadians()) * this.radius;\n    }\n    valueX() {\n      return this.midX + Math.cos(this.valueRadians()) * this.radius;\n    }\n    valueY() {\n      return this.midY - Math.sin(this.valueRadians()) * this.radius;\n    }\n    largeArc() {\n      return Math.abs(this.zeroRadians() - this.valueRadians()) < Math.PI ? 0 : 1;\n    }\n    sweep() {\n      return this.valueRadians() > this.zeroRadians() ? 0 : 1;\n    }\n    valueToDisplay() {\n      return this.valueTemplate.replace('{value}', this._value.toString());\n    }\n    get _value() {\n      return this.value != null ? this.value : this.min;\n    }\n  }\n  Knob.ɵfac = function Knob_Factory(t) {\n    return new (t || Knob)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  Knob.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: Knob,\n    selectors: [[\"p-knob\"]],\n    hostAttrs: [1, \"p-element\"],\n    inputs: {\n      styleClass: \"styleClass\",\n      style: \"style\",\n      severity: \"severity\",\n      valueColor: \"valueColor\",\n      rangeColor: \"rangeColor\",\n      textColor: \"textColor\",\n      valueTemplate: \"valueTemplate\",\n      name: \"name\",\n      size: \"size\",\n      step: \"step\",\n      min: \"min\",\n      max: \"max\",\n      strokeWidth: \"strokeWidth\",\n      disabled: \"disabled\",\n      showValue: \"showValue\",\n      readonly: \"readonly\"\n    },\n    outputs: {\n      onChange: \"onChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([KNOB_VALUE_ACCESSOR])],\n    decls: 5,\n    vars: 15,\n    consts: [[3, \"ngClass\", \"ngStyle\"], [\"viewBox\", \"0 0 100 100\", 3, \"click\", \"mousedown\", \"mouseup\", \"touchstart\", \"touchend\"], [1, \"p-knob-range\"], [1, \"p-knob-value\"], [\"text-anchor\", \"middle\", \"class\", \"p-knob-text\", 4, \"ngIf\"], [\"text-anchor\", \"middle\", 1, \"p-knob-text\"]],\n    template: function Knob_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(1, \"svg\", 1);\n        i0.ɵɵlistener(\"click\", function Knob_Template__svg_svg_click_1_listener($event) {\n          return ctx.onClick($event);\n        })(\"mousedown\", function Knob_Template__svg_svg_mousedown_1_listener($event) {\n          return ctx.onMouseDown($event);\n        })(\"mouseup\", function Knob_Template__svg_svg_mouseup_1_listener($event) {\n          return ctx.onMouseUp($event);\n        })(\"touchstart\", function Knob_Template__svg_svg_touchstart_1_listener($event) {\n          return ctx.onTouchStart($event);\n        })(\"touchend\", function Knob_Template__svg_svg_touchend_1_listener($event) {\n          return ctx.onTouchEnd($event);\n        });\n        i0.ɵɵelement(2, \"path\", 2)(3, \"path\", 3);\n        i0.ɵɵtemplate(4, Knob__svg_text_4_Template, 2, 5, \"text\", 4);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx.styleClass);\n        i0.ɵɵproperty(\"ngClass\", ctx.containerClass())(\"ngStyle\", ctx.style);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.size + \"px\")(\"height\", ctx.size + \"px\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"d\", ctx.rangePath())(\"stroke-width\", ctx.strokeWidth)(\"stroke\", ctx.rangeColor);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"d\", ctx.valuePath())(\"stroke-width\", ctx.strokeWidth)(\"stroke\", ctx.valueColor);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showValue);\n      }\n    },\n    dependencies: [i1.NgClass, i1.NgIf, i1.NgStyle],\n    styles: [\"@keyframes dash-frame{to{stroke-dashoffset:0}}.p-knob-range{fill:none;transition:stroke .1s ease-in}.p-knob-value{animation-name:dash-frame;animation-fill-mode:forwards;fill:none}.p-knob-text{font-size:1.3rem;text-align:center}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return Knob;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet KnobModule = /*#__PURE__*/(() => {\n  class KnobModule {}\n  KnobModule.ɵfac = function KnobModule_Factory(t) {\n    return new (t || KnobModule)();\n  };\n  KnobModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: KnobModule\n  });\n  KnobModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return KnobModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { KNOB_VALUE_ACCESSOR, Knob, KnobModule };\n//# sourceMappingURL=primeng-knob.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}